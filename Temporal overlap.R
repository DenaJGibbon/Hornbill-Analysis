# Summary  ----------------------------------------------------------------
# The goal is to compare the observed amount of call overlap to the expected
# based on multiple iterations of a randomly created dataset wherein call durations
# are the same but the start time and date for each call is randomized

# Observed = amount of time (s) both species called together

# Expected = a null distribution generated by repeated shuffling of the order of each species' observed calling durations with random between-call intervals

# We ignore recorder because we don't know how far they can hear each others' calls


# Load libraries ----------------------------------------------------------
library(stringr)
library(lubridate)
library(ggpubr)

# Load data ---------------------------------------------------------------
# Read in the .csv file with the data
AllHornBillData <- read.csv('KennedyEtAlHornBillData.csv')


# Calculate observed call overlap in actual dataset  -------------------------------------

# Check the structure of the data
head(AllHornBillData)

# Create a table of the number of observations by recorder and date
Hour.dataframe <- (table(AllHornBillData$Recorder,AllHornBillData$Date))

# Convert all values > 1 to 1
Hour.dataframe[Hour.dataframe > 0] <- 1 

# Calculate the number of recording hours analyzed
rowSums(Hour.dataframe)*24

# Create a new column that has only the hour in which calls were detected
AllHornBillData$Hour = str_split_fixed(AllHornBillData$Start.time,
                                       pattern = ':',n=3)[,1]


# Subset so only have detections (e.g. ignore dates where there were no calls)
AllHornBillDataCallsOnly <- droplevels(subset(AllHornBillData, Call.type !='none'))

# Convert duration to R friendly format
MinutestoSeconds <- as.numeric(str_split_fixed(AllHornBillDataCallsOnly$Duration,pattern = ':',n=3)[,2])*60
Seconds <- as.numeric(str_split_fixed(AllHornBillDataCallsOnly$Duration,pattern = ':',n=3)[,3] ) 

# Add a new call duration column to the dataframe
AllHornBillDataCallsOnly$CallDur <- MinutestoSeconds+Seconds

# Identify all unique dates in the dataset
DateIndex <- unique(AllHornBillData$Date)

# Create empty dataframe to add to 
ProportionOverlap <- data.frame()

# Loop over each date to identify overlapping calls
for(a in 1:length(DateIndex)){
  
  # Subset by date
  AllHornBillDataCallsOnlyTemp <- subset(AllHornBillDataCallsOnly, Date == DateIndex[a])
  
  # Sort calls so that they are in chronological order by start time
  AllHornBillDataCallsOnlyTemp <- AllHornBillDataCallsOnlyTemp[order(AllHornBillDataCallsOnlyTemp$Start.time),]
  
  # Create index by number of rows
  Nrows <- nrow(AllHornBillDataCallsOnlyTemp) -1
  
  # If there is more than one row
  if(Nrows > 1){
    
    # Loop over all rows
  for( b in 1: Nrows){
    
    # Subset two adjacent rows
    Temprow1 <- AllHornBillDataCallsOnlyTemp[b,]
    Temprow2 <- AllHornBillDataCallsOnlyTemp[b+1,]
    
    
    # Is the start time of the second call before the first?
    CallsOverlap <- strptime(Temprow2$Start.time, "%H:%M:%S") < strptime(Temprow1$End.time, "%H:%M:%S")
    
    # Is the call from the same species?
    SameSpecies <- Temprow1$Call.type == Temprow2$Call.type
    
    # If calls overlap and are from a different species 
    if(CallsOverlap==TRUE & SameSpecies==FALSE){
      Overlap <- 'TRUE'

      DurationOverlap <-  strptime(Temprow1$End.time, "%H:%M:%S") - strptime(Temprow2$Start.time, "%H:%M:%S")
      
      # We need to get the attributes of our duration, as it could be in mins or secs
      TimeAttributes <- attributes(DurationOverlap)
      
      # Convert duration to secs if it is minutes
      if(TimeAttributes$units =="mins"){
        DurationOverlap <- DurationOverlap*60
      }
      
      # In some cases the first call lasts longer than the second so we need to adjust for that
      if(DurationOverlap > Temprow2$CallDur ){
        DurationOverlap <- Temprow2$CallDur
      }
      
      # Create a temporary row
      Temprow1 <- cbind.data.frame(Temprow1,Overlap,DurationOverlap)
      
      # Add to overall dataframe
      ProportionOverlap <- rbind.data.frame(ProportionOverlap,Temprow1)
    } else {
      # If calls do not overlap or are from the same species
      Overlap <- 'FALSE'
      DurationOverlap <- 0
      
      # Create a temporary row
      Temprow1 <- cbind.data.frame(Temprow1,Overlap,DurationOverlap)
      
      # Add to overall dataframe
      ProportionOverlap <- rbind.data.frame(ProportionOverlap,Temprow1)
      
    }
   
  }
  
 } else {
   # If there is only only call per date
    if(nrow(AllHornBillDataCallsOnlyTemp) > 0){
    Overlap <- 'FALSE'
    DurationOverlap <- 0
    
    # Create a temporary row
    AllHornBillDataCallsOnlyTemp <- cbind.data.frame(AllHornBillDataCallsOnlyTemp,Overlap,DurationOverlap)
    # Add to overall dataframe
    ProportionOverlap <- rbind.data.frame(ProportionOverlap,AllHornBillDataCallsOnlyTemp)
    }
  }

  }

# Create a table for number of calls that overlap or don't
table(ProportionOverlap$Overlap)

# Subset only the calls that have overlap
OverlapTrueObserved <- subset(ProportionOverlap,Overlap =='TRUE')

# Find the calls directly after (e.g. the call that the first call overlaps with)
CallAfter <- ProportionOverlap[which(ProportionOverlap$Overlap =='TRUE')+1,]

# Combine into a dataframe
CombineCallsActual <- rbind.data.frame(OverlapTrue,CallAfter)

# Sort by start time to check output
CombineCallsActual[order(CombineCallsActual$Date,CombineCallsActual$Start.time),]

sum(OverlapTrueObserved$DurationOverlap)


# Calculate expected overlap using a randomization approach ------------------------------------------------------

# Create a series of dates and times within the range of existing data
possible_dates <- seq(as.POSIXct('2018/02/13'), as.POSIXct('2018/04/11'), by="1 secs")

# Check range of output
range(possible_dates)

#  Prepare data to remove hours when hornbills did not call

## Split hour from the rest of the time
Removetime <- str_split_fixed(possible_dates,pattern = ':',n=3)[,1]

## Split hour from date
possible_dates_hours <- str_split_fixed(Removetime,pattern = ' ',n=2)[,2]

## Convert to numeric
possible_dates_hours <- as.numeric(possible_dates_hours)

# Subset to only include times when the hornbills call 
possible_dates <- possible_dates[which(possible_dates_hours >=5 & possible_dates_hours <= 18)]

# Create empty list to store values
SimOverlapList <- list()

# Number of random iterations
Niterations <- 500

# Randomization loop to calculate 
for(z in 1:Niterations){
print(z)
# Randomly sample the number of calls in our existing data set
PossibleDatesSub <- sample(possible_dates, nrow(AllHornBillDataCallsOnly),replace = TRUE)

# Create a column for date
Date <- as.Date(PossibleDatesSub)

# Create an end time value using the actual call durations in the dataset
Endtime <- PossibleDatesSub + seconds(AllHornBillDataCallsOnly$CallDur)

# Create new simulated dataframe
SimulatedHornBillDataCalls <- cbind.data.frame(Date,PossibleDatesSub,Endtime,AllHornBillDataCallsOnly$Call.type,AllHornBillDataCallsOnly$CallDur)

# Add new column names
colnames(SimulatedHornBillDataCalls) <- c('Date','Start.time','End.time','Call.type','CallDur')

# Create a date index
SimDateIndex <- unique(SimulatedHornBillDataCalls$Date)

# Create empty dataframe
SimProportionOverlap <- data.frame()

# Loop to identify calls that overlap temporally
for(a in 1:length(SimDateIndex)){
 
  # Subset based on date; remove any NAs
  SimulatedHornBillDataCallsTemp <- (subset(SimulatedHornBillDataCalls, Date == SimDateIndex[a]))
  
  # Sort calls based on start time
  SimulatedHornBillDataCallsTemp <- SimulatedHornBillDataCallsTemp[order(SimulatedHornBillDataCallsTemp$Start.time),]
  
  # Calculate number of rows
  Nrows <- nrow(SimulatedHornBillDataCallsTemp) -1
  
  # Loop to identify overlapping calls if there was more than one call per day
  if(Nrows > 1){
    for( b in 1: Nrows){
      # Subset two adjacent rows
      Temprow1 <- SimulatedHornBillDataCallsTemp[b,]
      Temprow2 <- SimulatedHornBillDataCallsTemp[b+1,]
      
      # Do calls overlap (e.g. is the start time of the second call before the end time of the first)
      CallsOverlap <- Temprow2$Start.time < Temprow1$End.time
      
      # Are the calls from the same species?
      SameSpecies <- Temprow1$Call.type == Temprow2$Call.type
      
      # If call durations overlap and the calls are from the same species
      if(CallsOverlap==TRUE & SameSpecies==FALSE){
        # Set overlap = TRUE
        Overlap <- 'TRUE'
        
        # Calculate duration of overlap
        DurationOverlap <- Temprow2$Start.time - Temprow1$End.time
          
        # We need to get the attributes of our duration, as it could be in mins or secs
        TimeAttributes <- attributes(DurationOverlap)
        
        # Convert duration to secs if it is minutes
        if(TimeAttributes$units =="mins"){
          DurationOverlap <- DurationOverlap*60
        }
        
        
        # In some cases the first call lasts longer than the second so we need to adjust for that
        if(DurationOverlap > Temprow2$CallDur ){
          
          DurationOverlap <- Temprow2$CallDur
        }
        
        # Create a new temporary row
        Temprow1 <- cbind.data.frame(Temprow1,Overlap,DurationOverlap)
        
        # Add new row to existing dataframe
        SimProportionOverlap <- rbind.data.frame(SimProportionOverlap,Temprow1)
      
        } else {
        # If calls do not overlap or are from the same species we create a row indicating this  
        Overlap <- 'FALSE'
        DurationOverlap <- 0
        
        # Create a new temporary row
        Temprow1 <- cbind.data.frame(Temprow1,Overlap,DurationOverlap)
        
        # Add new row to existing dataframe
        SimProportionOverlap <- rbind.data.frame(SimProportionOverlap,Temprow1)
        
      }
      
    }
    
  } else {
    # In some cases there will be only one call per date
    if(nrow(SimulatedHornBillDataCallsTemp) > 0){
      Overlap <- 'FALSE'
      DurationOverlap <- 0
      
      # Create a new temporary row
      SimulatedHornBillDataCallsTemp <- cbind.data.frame(SimulatedHornBillDataCallsTemp,Overlap,DurationOverlap)
      
      # Add new row to existing dataframe
      SimProportionOverlap <- rbind.data.frame(SimProportionOverlap,SimulatedHornBillDataCallsTemp)
    }
  }
  
}

# Subset based on calls that had overlap
OverlapTrue <- subset(SimProportionOverlap,Overlap =='TRUE')

# CallAfter <- SimProportionOverlap[which(SimProportionOverlap$Overlap =='TRUE')+1,]
# 
# CombinedCalls <- rbind.data.frame(OverlapTrue,CallAfter)

OverlapValue <- sum(abs(OverlapTrue$DurationOverlap))

if (is.na(OverlapValue)==TRUE) {
  break
}

SimOverlapList[[z]] <- OverlapValue
print(OverlapValue)
}


# Create density plot -----------------------------------------------------

# Create vector of simulated overlap values
SimOverlapVals <- unlist(SimOverlapList)

# Create density plot with median expected (dashed black) and observed (red)
ggdensity(data=SimOverlapVals, add=c('median'), fill='lightgrey') + 
  geom_vline(xintercept = sum((OverlapTrueObserved$DurationOverlap)), col='red' )+
  xlim(500,5000)+
  xlab('Duration overlap (s)') + ylab('Density')

((SimOverlapVals))/sum((CombineCallsActual$DurationOverlap))

median(((SimOverlapVals)))

# Calculate p-value 
ExpectedVsObserved <- ((SimOverlapVals)) >= sum((CombineCallsActual$DurationOverlap))
p.values <- sum(ExpectedVsObserved)
p.values/length((na.omit(SimOverlapVals)))

